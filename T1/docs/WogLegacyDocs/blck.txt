struct _DataBlock_ {
	int length;
	Byte* data;
};

List<_DataBlock_> vl_temp;
List<_DataBlock_> vl_perm;

Add(List<_DataBlock_>& list, const char name[], int len); // fill with zeros
Remove(List<_DataBlock_>& list, const char name[]);
Save(List<_DataBlock_>& list);
Load(List<_DataBlock_>& list);
Reset(List<_DataBlock_>& list);



VA receiver - Named DataBlocks, Value Slots

Create named memory blocks, to store numerical or string variables and arrays.
Allows to store (virtually) unlimited data, and easily exchange data between Lua and ERM.

Introduced in Alpha 8.2

mode
	= 0 blocks are local for current game, and stored in savefile
	= 1 blocks are temporary, removed every time game is started or loaded
	= 2 blocks are permanent, not bound to savefile and are not removed automatically
VA(mode):A(name,?val) wyjebaÄ‡
VA(mode):C(name,?val,?val) // Check whether named block exists (returns address, then length)
VA(mode):R(name) // Remove datablock with given name
VA(mode):B(name, n) // Initialise (create) array of bytes
VA(mode):B(name, i, ?val) // Get/set value of byte in array
VA(mode):V(name, n) // Initialise (create) array of v-vars (integers)
VA(mode):V(name, i, ?val) // Get/set value of v-var in array
VA(mode):Z(name, n) // // Initialise (create) array of z-strings
VA(mode):Z(name, i, ?z) // Get/set value of z-var in array -- CHECK IF CONSTANT STRING MIGHT BE USED

indexing from 0

It's best to use "modular" naming convention, to prevent overlapping. For example, name "wog_name" would be WoG variable. Claimed variable "wog_" would mean that 'namespace' wog_ is claimed and can't be used, which can be useful for running multiple mods and checking whether they overlap.
You can use any string (up to 31 characters) as name, so you have some space for ya. Lettercase MATTERS.

all arrays by default are filled with zeros.
Note: there's no distinction between datablocks created using VA:B, VA:V and VA:Z. Those are created for easier usage of those blocks, but for executable, datablock is just array of bytes with length stored in integer right before.
You can access any datablock using any of these, it won't cause ERM error - however you'll likely find non-sensical data inside, and doing so is considered a very poor idea.

You can create single variables by creating arrays with length=1, for example
!#VA0:V^wog_example^/1; 
will create array with only one v-var inside, which you can access using
!#VA0:V^wog_example^/0/?v1;
index=0 because we're using C notations, indexing from 0 up to (length-1)

Memory slots (VA Receiver) are cool, grants many new posibilities, but comes with handicap: they are SLOW. Because of that slowness, you should avoid accessing them in loops. Best idea is to get value from slot into temporary variable (y-var), do some operations on this var, then write it into memory slot
Example:
!?PI;
!!VA0:V^wog_example^/0/?y1;
... [do some operations here]
!!VA0:V^wog_example^/0/?y1;